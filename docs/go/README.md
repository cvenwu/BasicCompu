# Go语言相关

!> **Golang**相关的面试题

## 基本数据结构

### 数组未初始化能不能求len
可以，例如 `var a [5]int` 将会赋对应类型的零值
没有初始化的意思就是没有赋值
注意：切片只是声明相当于一个nil，可以直接不断append进行追加元素

### 未初始化的slice能不能append


### go数组和slice的区别
1. 数组定长，定义的时候就需要确定。切片长度不定，append时会自动扩容
2. 相同大小数组可以赋值，会拷贝全部内容。slice赋值和指针一样。数组和slice之间不能相互赋值。当然slice有自己的copy函数
3. 数组也可以进行切片，返回值是一个slice，改变slice时会同步修改数组内容，相当于取得了这个数组的指针

### slice底层实现


### slice的底层原理
### map的底层原理
### Map是线程安全的吗？怎么解决并发安全问题
### Go切片和数据之间的区别
### 切片和数组区别和底层
### go 常见数据结构
### go map结构实现，并发安全否
### Slice、map都是安全的吗
### Golang中的 map 以及 slice 的源码分析以及slice内存泄漏，需要了解什么是内存泄漏

###  切片怎么扩容,扩容过程中需不需要重新写入

----------
## channel 管道

### channel 有缓冲 无缓冲

!> [参考](https://www.flysnow.org/2017/04/17/go-in-action-go-channel.html)
1. 注意点：如果一个通道被关闭了，我们就不能往这个通道里发送数据了，如果发送的话，会引起painc异常。但是，我们还可以接收通道里的数据，如果通道里没有数据的话，接收的数据是零值.
2. 无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送goroutine和接收goroutine同时准备好，才可以完成发送和接收操作。
3. 从上面无缓冲的通道定义来看，发送goroutine和接收gouroutine必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。
4. 有缓冲通道内部有一个类似于队列机制的缓冲区，定义的时候通过make的第2个参数指定缓冲区大小，如果容量满了，接收将会阻塞，如果缓冲区空，发送将会阻塞。
5. 如果给定了一个缓冲区容量，那么通道就是异步的，只要缓冲区有未使用空间用于发送数据，或还包含可以接收的数据，那么其通信就会无阻塞地进行

类似问题： go的channel 有缓冲无缓冲如何定义，区别 

## 关闭channel读取后会怎样

----------


## 内存泄漏


### goroutine内存泄漏场景
[参考](https://blog.csdn.net/leeright/article/details/94466831)
goroutine泄漏描述：如果你启动了一个 goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是 goroutine 泄露。

### go中导致内存泄漏的原因

### 了解内存泄漏吗？有什么危害？


### go 内存分配


----------
## 协程与并发
### go并发为什么快
### go协程 java线程区别
### sync.Once的实现原理
!>（上次哔哩哔哩面试问到了，幸亏我事后看了一眼是类似双重检验锁的实现方式哦），让我写出来，我写出了一大半，还让我运行一下，我运行不出来
### context包有没有用过，我说没用过
###  进程，线程，协程的区别

### sync.Map 怎么解决线程安全问题？看过源码吗？
### golang 的 waitGroup 用法

### Go的协程可以不可以自己让出cpu
### Go的协程可以只挂在一个线程上面吗
### 一个协程挂起换入另外一个协程是什么过程？
### golang中channel调用问题，
### 有一个高并发的场景该怎么处理
### golang 协程机制
### 协程的栈空间大小有限制吗？会主动扩展吗？
### golang context 应用场景
### context 的数据结构（树）
### go 协程
### go 同步，channel的实现
### go 协程怎么切换的
### Golang 的协程与 Java 线程的区别？
协程是轻量级线程，多个协程可以由一个或多个线程管理。
协程无需上下文切换，没有线程之间切换的开销。
协程的调度不需要多线程的锁机制，因为只有一个线程，不存在同时写变量冲突，执行效率比多线程高很多。
这题面试的时候没有答到第三点。
### Golang 的协程间通讯方式有哪些？
共享内存和协程通信。
「Don’t communicate by sharing memory, share memory by communicating」所以更提倡使用 channel 进行通信。
当时答的时候也只答了 channel，面试官说还有一种，怎么都想不起来Orz。
###  Go里面一个协程能保证绑定在一个内核线程上面的。

### go多线程
### golang协程i/o多路复用机制



### 线程安全的map锁分段的细节

----------
## GMP与垃圾回收

### go垃圾回收
### go gmp 调度 4次
### go 垃圾回收，什么时候触发 2次
### GMP源码级别分析
### go 内存逃逸分析（分析了栈帧，讲五种例子，描述堆栈优缺点，点头）



----------

## 性能问题排查

### golang 性能问题怎么排查？（profile）
### 项目调试（讲了下GDB）
### gdb
----------
## 异常处理
### defer recover 的问题（自己了解不多，简单介绍）
### go defer
### defer的执行顺序
### defer A ; defer B ; defer panic("") A和B能不能执行到
### defer recover panic 执行顺序
----------

## 其他问题
### go怎样实现继承

### socket

### gin框架如何实现，我说用go内置的net http包实现的
### 逃逸分析讲一下

### copy是操作符还是内置函数
### 一道很简单的Go题目，Go怎么做深拷贝。

### golang有什么设计很巧妙的地方吗，举几个例子。
### 实现string ，拷贝构造，主要内存开辟析构（没答好)
### go语言的性能的优劣
### 了解中间件吗?有什么好处

### Golang 的默认参数传递方式以及哪些是引用传递？
默认采用值传递，且Go 中函数传参仅有值传递一种方式。
slice、map、channel 都是引用类型。
slice 能够通过函数传参后，修改对应的数组值，因为 slice 内部保存了引用数组的指针，并不是因为引用传递。
这题回答的时候以为有引用传递，答了 slice、map、channel 都是引用传递，结果一百度，发现是用起来像引用传递，其实都是值传递，就像 slice 传递的是指针的复制。



### etcd 原理（讲了下raft协议）

### go相关知识点（内存分配、go优缺点、go错误处理有什么优缺点）
一个GO源码级别的仓库讲解：https://github.com/bereborn/learn/blob/master/go/go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.c


### RPC
