# 操作系统
!> **操作系统** 面试题以及答案整理

## 进程 线程 协程


### 进程，线程，协程以及他们的区别
> 操作系统为了跟踪每个进程的活动状态，维护了一个进程表。进程表的内部列出了每个进程的状态以及每个进程使用的资源等。

进程：正在执行程序的一个实例，是资源分配的基本单位。（进程控制块（process control block）描述进程的基本信息和运行状态，所谓的创建和撤销进程，都是指对PCB的操作）
线程：进程中的单条流向，是程序独立调度的基本单位。

**区别：**
1. （拥有资源）一个进程可以有多个线程，由于线程不拥有资源，这几个线程共享进程内的资源。
2. （资源开销）创建和撤销线程比进程开销小很多，因为创建线程仅仅需要堆栈空间以及程序计数器就可以了而创建进程需要分配地址空间，数据资源等，开销比较大。
3. （调度）由于线程是独立调度的基本单位，同一进程中线程的切换不会引起进程的切换，但是两个不同进程中的线程切换会引起进程切换。
4. （通信）线程可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。

[参考](https://mp.weixin.qq.com/s/_XPzjzM6Tp1KoeYJBOOTCg)
[参考2](https://www.cnblogs.com/wangtong111/p/11213299.html)
[参考3](https://zhuanlan.zhihu.com/p/345412382)
[参考4](https://www.bilibili.com/video/BV1H541187UH?from=search&seid=18006703396903851168) 
[参考5](https://zhuanlan.zhihu.com/p/260830550)




|   |  进程   |  线程   |  协程   |
| :--: | :--: | :--: | :--: |
|   |   |   |   |
|      |      |      |      |
|      |      |      |      |


上面的参考4做的笔记：
每个进程都有自己的虚拟地址空间，但是为了进一步保障系统运行安全，虚拟地址空间被划分为用户空间和内核空间，操作系统运行在内核空间，用户程序运行在用户空间，内核空间由所有进程的地址空间共享（所有进程的内核空间（3G－4G）都是共享的  属于所有进程。内核层共享，只是为了提供内核应该提供的访问接口。这样应用程序才能通过这些空间来和内核交互，以及调用其他功能和访问硬件。），但是用户程序不能直接访问内核空间，操作系统保存的进程控制信息自然是在内核空间，这里除了页目录以外还能找到很多重要的内容，例如进程和父进程ID，状态，打开文件句柄表等等


线程就是进程中的执行体，它要有指定的执行入口，通常是某个函数的指令入口，线程执行时要使用从进程虚拟地址空间中分配的栈空间来存储数据，这被称为线程栈，在创建线程时， 操作系统会在用户空间和内核空间分别分配两段栈，就是我们通常所说的用户栈和内核栈，线程切换到内核态执行时会使用内核栈，为的是不允许用户代码对其进行修改以保证安全，操作系统也会记录每个线程的控制信息（例如执行入口，线程栈，线程id），windows中线程控制信息对应TCB，在PCB中可以找到进程拥有的线程列表，同一个进程内的线程会共享进程的地址空间和句柄表等资源，而在linux中只使用了一个task_struct结构体，进程在创建子进程时会指定它和自己使用同一套地址空间和句柄表等资源，用这种方法来实现多线程的效果，


![jDend6](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/jDend6.png) -> ![OBSUxB](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/OBSUxB.png) -> ![fxNsLb](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/fxNsLb.png) -> ![BjNBU7](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/BjNBU7.png) -> ![4K7g2Y](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/4K7g2Y.png) -> ![rpFLY1](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/rpFLY1.png) -> ![z5MU89](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/z5MU89.png)


如果接下来要执行进程A中的线程a1，执行入口如图所示在那里，cpu的指令指针就会指向线程的执行入口，当前执行用户空间的程序指令，所以栈基和栈指针寄存器会记录用户栈的位置，可以看到程序执行时，cpu面向的是某个线程，所以才说线程是操作系统调度和执行的基本单位，一个进程中至少要有一个线程，它要从这个线程开始执行，这被称为它的主线程，可以认为主线程是进程中的第一个线程，一般是由父进程或者操作系统创建的，而进程中的其他线程，一般都是由主线程创建的，线程中发生函数调用时就会在线程栈中分配函数调用栈，而虚拟内存分配，文件操作，网络读写等很多功能，都是由操作系统来实现，再向用户程序暴露接口，所以，线程免不了要调用os提供的系统服务，也就是少不了进行系统调用，cpu中会有一个特权级标志，用户记录当前程序是在用户态还是内核态，只有标记为内核态时才可以访问内核空间，而目前线程a1处于用户态，还不能访问内核空间，所以系统调用发生时就得切换到内核态，使用线程的内核栈，执行内核空间的系统函数，这被称为从"用户态"切换到"内核态"。最初系统调用是通过软中断触发的，所谓软中断，就是通过指令模拟中断，与软中断对应的是硬件中断，操作系统会按照cpu硬件要求，在内存里存一张中断向量表，用来把各个中断编号映射到相应的处理程序，例如Linux系统中，系统调用中断对应的编号为0x80，对应的处理程序就是用来派发系统调用的，为什么说派发系统调用呢？因为操作系统提供了数百个系统调用，不能为每一个都分配一个中断号，所以操作系统又实现了一张系统调用表，用于通过系统调用编号，找到对应的系统函数入口，所以用户程序这里，会把要调用的系统函数编号存入特定寄存器，通过寄存器或用户栈来传递其他所需参数，然后用int 0x80来触发系统调用中断，而硬件层面，CPU有一个中断控制器，它负责接收中断信号，切换到内核态，保存用户态执行现场，一部分寄存器的值会通过硬件机制保存起来，还有一部分通用寄存器的值，被压入内核栈中，然后去中断向量表这里查询0x80对应的系统调用派发程序入口，而系统调用的派发程序会根据指定的系统调用编号，去系统调用表这里查询对应的系统调用入口并执行，后来为了优化系统调用的性能，改为通过特殊指令触发系统调用，例如x86的sysenter，和amd64平台下的syscall，当cpu执行到这些指令时就会陷入内核态，从专用寄存器拿到派发入口的地址，省去了查询中断向量表的过程，等系统调用结束后，再利用之前保存的信息，恢复现场在用户态的执行现场，继续执行后面的指令，这样就完成了一次系统调用。ok，对线程的调用有一个大致了解。

![EOZqYs](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/EOZqYs.png)

接下来就可以看看线程切换是怎么回事了？
我们知道现代操作系统中，cpu的执行权被划分为不同的时间片，只有获得cpu时间片的程序才可以运行，由于时间片很短，所以用户感觉不到程序的切换过程，又因为cpu很快，所以即使很短的时间片，也足够它执行很多很多的指令，一个线程获得的时间片用完时，cpu硬件时钟会触发一次时钟中断，对应的中断处理程序，会从已经就绪的线程中挑选一个来执行，我们暂不展开线程调度的问题，只关注切换过程。
例如接下来要从线程a1切换到线程a2，这两个线程同属于进程A，那么这就涉及到线程切换，![ZGnbNl](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/ZGnbNl.png) 
只需要把线程a1的执行现场保存起来，后续再把指令指针，栈指针这些寄存器的值，修改为线程a2的信息，修改一下内存中调度相关的数据结构，一次同进程间的线程切换就算完成了。

![MAiBJ8](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/MAiBJ8.png) -> ![64R8Kv](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/64R8Kv.png)

等到线程a1再次获得时间片之后，会根据之前保存的信息，恢复到切换前的执行现场，继续完成它的任务，假如线程a1要切换到另一个进程B的线程b1，那么除了线程切换外还有涉及到进程切换，cpu这里保存的页目录地址要切换到进程B，所以进程切换与线程切换的区别就是进程切换会导致地址空间等进程资源发生变化，会导致TLB缓存失效，代价相应的会更大。
![WKJXR1](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/WKJXR1.png) -> ![6dCq7x](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/6dCq7x.png)


到目前为止，我们已经了解了进程和线程的结构，(如下图所示)
![Eqwwvs](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Eqwwvs.png)
理解了线程的用户栈和内核栈，(如下图所示)
![S0d8KU](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/S0d8KU.png)

以及进程切换与线程切换的大致过程，(如下图所示)
![WKJXR1](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/WKJXR1.png) -> ![6dCq7x](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/6dCq7x.png)

不过时间片轮转也只是触发进程或线程切换的多种场景之一，


![6ZmMEq](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/6ZmMEq.png)

### 进程与线程区别
1. 进程是资源分配的基本单位，线程是独立运行和独立调度的基本单位(CPU上真正运行的是线程)
2. 进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源
3. 线程的调度与切换比进程快很多

### 进程之间如何通信
进程间通信：(Inter process communication)
几种方式：
1. 消息队列：消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程中间提供全双工通信连接
2. 管道：用于两个相关进程间通信，是一种半双工的通信方式，只能在父子进程中使用，如果需要全双工，需要另外的一个管道。
3. 先进先出队列：两个不相关的进程之间的通信，是一种全双工的通信方式。同时不需要父子进程关系。
4. 套接字：与其他通信方式不同，可以用于不同机器之间的进程通信。
5. 信号量：是一个计数器，用于为多个进程提供对共享数据对象的访问
6. 共享内存：使用所有进程的内存来建立连接，不过需要同步进程（信号量）来保护访问。是最快的IPC方式。
7. 直接通信：进程间只存在一条连接，因此要明确双方的命名。
8. 间接通信：通信双方不会直接建立连接，通过一个中介，进程可以在中介放置和删除消息以此达到进程通信
9. 消息传递：消息传递是进程间实现通信和同步等待的机制。消息直接由发送方传递给接收方。

无名管道，命名管道，共享内存，消息队列，套接字（分别有哪些例子）


[参考](https://mp.weixin.qq.com/s/_XPzjzM6Tp1KoeYJBOOTCg)
类似问题：进程间怎样通信

### 进程的生命周期

### 进程调度
### 并发与并行

并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。

并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。

注意点：**并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』**

一个让人更加容易理解的例子：
1. 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
2. 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
3. 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。

### 线程共享的有什么，不共享的有什么
**共享的资源有：**
1. 堆。 由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）
2. 全局变量 。它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的
3. 静态变量。 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的
4. 文件等公用资源。 这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。

**独享的资源有：**
1. 栈 。栈是独享的
2. 寄存器 。 这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC


[参考](https://blog.csdn.net/qq_41257129/article/details/104313432)

### 孤儿进程的区别，如何解决孤儿进程的出现
### 了解锁么，如何实现一个锁
### 上层协程结束了，如果通知到子协程也结束
### 用户态和内核态
### 线程的上下文切换
### 内核态线程和用户态线程的区别如何切换
### 上下文切换的细节
### fork之后的父子进程虚拟内存空间的相同与不同
### 多线程中会对全局变量进行pad操作，请问是为啥？
面试官解释说是padding操作，也就是struct中的内存对其那种
### 一个线程是如何被挂起的
### 一个进程是如何被挂起的
### 线程之间的通信方式
### 进程池 线程池
### 上下文切换的细节
### 内核态线程和用户态线程的区别如何切换

### 多线程线程的弊端

### 线程的上下文切换

### 用户态和内核态

### 什么是线程安全
[参考](https://mp.weixin.qq.com/s/WDeewsvWUEBIuabvVVhweA)

### 进程、线程究竟是由什么组成的？有哪些数据？

### 进程调度算法


-------------

## IO模型

### IO和多路复用
### epoll的底层实现
### io多路复用的类别
### Io模型
### select、epoll
### Epoll

--------

### 死锁
### 操作系统死锁的问题
### 死锁以及怎样避免
### 死锁的必要条件
### 死锁的预防
### 死锁的处理策略（死锁预防、死锁检测与恢复、死锁避免）
--------
## 内存

### 了解虚拟内存吗？什么是虚拟内存？为什么要有虚拟内存？
### mmu有了解吗? 讲讲mmu
### 内存分页的目的是什么？
### 内存管理，包括：虚拟内存（重点）、分页、分段、分页系统地址映射、内存置换算法（重点）。

------------

## 其他

### CPU密集型（CPU-bound）与 IO密集型（I/O bound）

#### CPU密集型（CPU-bound）
1. CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。
2. 在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。
3. CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。

#### IO密集型（I/O bound）

1. IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。
2. I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。
3. 计算密集型任务需要大量的计算，虽然多任务也可以完成计算密集型任务，但是任务越多花在任务切换时间越多，CPU执行任务的效率越低，所以要高效利用CPU，采用多进程开发。
4. IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率（**原因就是因为计算不是短板，IO是短板，所以提高IO才会显著提升性能**）。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。

总结：**CPU密集型任务使用多进程，IO密集型任务使用多线程**

### 内存泄漏与内存溢出：
1. ![2SMulF](https://gitee.com/yirufeng/images/raw/master/uPic/2SMulF.png)
2. ![AlhrJW](https://gitee.com/yirufeng/images/raw/master/uPic/AlhrJW.png)
3. ![tmwKDK](https://gitee.com/yirufeng/images/raw/master/uPic/tmwKDK.png)

### 阻塞与非阻塞
1. 阻塞是指调用线程或者进程被操作系统挂起。
2. 非阻塞是指调用线程或者进程不会被操作系统挂起。

### 同步与异步
同步是阻塞模式，异步是非阻塞模式。

同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，知道收到返回信息才继续执行下去；
异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。
由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。看[下图](https://zhuanlan.zhihu.com/p/70256971)

[参考](https://zhuanlan.zhihu.com/p/70256971)
### 堆 栈 区别
### 操作系统中的锁
### socket的概念
### 磁盘转一次要多久
### CPU负载过高了怎么办，问题定位

### 磁盘寻道算法

### 程序执行的交互过程，CPU，OS，内存和磁盘都要涉及。

### LinuxIO 的原理，具体 IO 过程介绍。