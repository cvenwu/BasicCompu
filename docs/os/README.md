# 操作系统
!> **操作系统** 面试题以及答案整理

## 进程 线程 协程

### 进程，线程，协程以及他们的区别
> 操作系统为了跟踪每个进程的活动状态，维护了一个进程表。进程表的内部列出了每个进程的状态以及每个进程使用的资源等。

进程：正在执行程序的一个实例，是资源分配的基本单位。（进程控制块（process control block）描述进程的基本信息和运行状态，所谓的创建和撤销进程，都是指对PCB的操作）
线程：进程中的单条流向，是程序独立调度的基本单位。

**区别：**
1. （拥有资源）一个进程可以有多个线程，由于线程不拥有资源，这几个线程共享进程内的资源。
2. （资源开销）创建和撤销线程比进程开销小很多，因为创建线程仅仅需要堆栈空间以及程序计数器就可以了而创建进程需要分配地址空间，数据资源等，开销比较大。
3. （调度）由于线程是独立调度的基本单位，同一进程中线程的切换不会引起进程的切换，但是两个不同进程中的线程切换会引起进程切换。
4. （通信）线程可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。

[参考](https://mp.weixin.qq.com/s/_XPzjzM6Tp1KoeYJBOOTCg)
[参考2](https://www.cnblogs.com/wangtong111/p/11213299.html)
[参考3](https://zhuanlan.zhihu.com/p/345412382)
[参考4](https://www.bilibili.com/video/BV1H541187UH?from=search&seid=18006703396903851168)
[参考5](https://zhuanlan.zhihu.com/p/260830550)


### 进程与线程区别
1. 进程是资源分配的基本单位，线程是独立运行和独立调度的基本单位(CPU上真正运行的是线程)
2. 进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源
3. 线程的调度与切换比进程快很多

### 进程之间如何通信
进程间通信：(Inter process communication)
几种方式：
1. 消息队列：消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程中间提供全双工通信连接
2. 管道：用于两个相关进程间通信，是一种半双工的通信方式，只能在父子进程中使用，如果需要全双工，需要另外的一个管道。
3. 先进先出队列：两个不相关的进程之间的通信，是一种全双工的通信方式。同时不需要父子进程关系。
4. 套接字：与其他通信方式不同，可以用于不同机器之间的进程通信。
5. 信号量：是一个计数器，用于为多个进程提供对共享数据对象的访问
6. 共享内存：使用所有进程的内存来建立连接，不过需要同步进程（信号量）来保护访问。是最快的IPC方式。
7. 直接通信：进程间只存在一条连接，因此要明确双方的命名。
8. 间接通信：通信双方不会直接建立连接，通过一个中介，进程可以在中介放置和删除消息以此达到进程通信
9. 消息传递：消息传递是进程间实现通信和同步等待的机制。消息直接由发送方传递给接收方。

无名管道，命名管道，共享内存，消息队列，套接字（分别有哪些例子）


[参考](https://mp.weixin.qq.com/s/_XPzjzM6Tp1KoeYJBOOTCg)
类似问题：进程间怎样通信


### 并发与并行

并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。

并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。

注意点：**并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』**

一个让人更加容易理解的例子：
1. 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
2. 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
3. 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。

### 线程共享的有什么，不共享的有什么
**共享的资源有：**
1. 堆。 由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）
2. 全局变量 。它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的
3. 静态变量。 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的
4. 文件等公用资源。 这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。

**独享的资源有：**
1. 栈 。栈是独享的
2. 寄存器 。 这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC


[参考](https://blog.csdn.net/qq_41257129/article/details/104313432)

### 孤儿进程的区别，如何解决孤儿进程的出现
### 了解锁么，如何实现一个锁
### 上层协程结束了，如果通知到子协程也结束
### 用户态和内核态
### 线程的上下文切换
### 内核态线程和用户态线程的区别如何切换
### 上下文切换的细节
### fork之后的父子进程虚拟内存空间的相同与不同
### 多线程中会对全局变量进行pad操作，请问是为啥？
面试官解释说是padding操作，也就是struct中的内存对其那种
### 一个线程是如何被挂起的
### 一个进程是如何被挂起的
### 线程之间的通信方式
### 进程池 线程池
### 上下文切换的细节
### 内核态线程和用户态线程的区别如何切换

### 多线程线程的弊端

### 线程的上下文切换

### 用户态和内核态

### 什么是线程安全

### 进程、线程究竟是由什么组成的？有哪些数据？

### 进程调度算法


-------------

## IO模型

### IO和多路复用
### epoll的底层实现
### io多路复用的类别
### Io模型
### select、epoll
### Epoll

--------

### 死锁
### 操作系统死锁的问题
### 死锁以及怎样避免
### 死锁的必要条件
### 死锁的预防
### 死锁的处理策略（死锁预防、死锁检测与恢复、死锁避免）
--------
## 内存

### 了解虚拟内存吗？什么是虚拟内存？为什么要有虚拟内存？
### mmu有了解吗? 讲讲mmu
### 内存分页的目的是什么？
### 内存管理，包括：虚拟内存（重点）、分页、分段、分页系统地址映射、内存置换算法（重点）。

------------

## 其他

### CPU密集型（CPU-bound）与 IO密集型（I/O bound）

#### CPU密集型（CPU-bound）
1. CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。
2. 在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。
3. CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。

#### IO密集型（I/O bound）

1. IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。
2. I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。
3. 计算密集型任务需要大量的计算，虽然多任务也可以完成计算密集型任务，但是任务越多花在任务切换时间越多，CPU执行任务的效率越低，所以要高效利用CPU，采用多进程开发。
4. IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率（**原因就是因为计算不是短板，IO是短板，所以提高IO才会显著提升性能**）。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。

总结：**CPU密集型任务使用多进程，IO密集型任务使用多线程**

### 内存泄漏与内存溢出：
1. ![2SMulF](https://gitee.com/yirufeng/images/raw/master/uPic/2SMulF.png)
2. ![AlhrJW](https://gitee.com/yirufeng/images/raw/master/uPic/AlhrJW.png)
3. ![tmwKDK](https://gitee.com/yirufeng/images/raw/master/uPic/tmwKDK.png)

### 阻塞与非阻塞
1. 阻塞是指调用线程或者进程被操作系统挂起。
2. 非阻塞是指调用线程或者进程不会被操作系统挂起。

### 同步与异步
同步是阻塞模式，异步是非阻塞模式。

同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，知道收到返回信息才继续执行下去；
异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。
由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。看[下图](https://zhuanlan.zhihu.com/p/70256971)

[参考](https://zhuanlan.zhihu.com/p/70256971)
### 堆 栈 区别
### 操作系统中的锁
### socket的概念
### 磁盘转一次要多久
### CPU负载过高了怎么办，问题定位

### 磁盘寻道算法