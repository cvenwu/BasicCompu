# Mysql

!> mysql面试题

重点：事务，隔离级别，锁，索引，存储引擎

-----------

## References
1. [参考](极客时间课程mysql实战45讲)
2. [参考](https://zhuanlan.zhihu.com/p/85990712)
3. [参考](https://blog.csdn.net/sanyuesan0000/article/details/90235335)
4. [参考](https://www.cnblogs.com/chenglc/p/10912340.html)
5. [参考](https://zhuanlan.zhihu.com/p/140876416)
6. [参考2](https://zhuanlan.zhihu.com/p/222958908)
7. [mysql日志系统](https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247485074&idx=1&sn=0fcce3bb06f5dc874ef976248df5770e&chksm=e80db0e4df7a39f2452e5d185a50e0a2497e0ff5db7464faf25b29ef1f00f9fe185c4361e060&scene=21#wechat_redirect)
8. [面试问烂的 MySQL 四种隔离级别，看完吊打面试官！](https://zhuanlan.zhihu.com/p/76743929)
9. [MySQL事务隔离级别和实现原理（看这一篇文章就够了！）](https://zhuanlan.zhihu.com/p/117476959)

------------
## 事务
> 在 MySQL 中，事务支持是在引擎层实现的
> MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一

!>事务是什么：**事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位**，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

### 事务的特点或特性
> 类似问题： 数据库用的是什么？说说数据库事务的特性。
> 类似问题：ACID 是什么？具体介绍一下。

!> ACID：分别对应原子性atomicity，一致性consistency，隔离性isolation，持久性durability
1. **原子性**，是指一个事务操作不可分割，要么成功，要么失败，不能有一半成功一半失败的情况。
2. **一致性**：**是指这些数据在事务执行完成这个时间点之前，读到的一定是更新前的数据，之后读到的一定是更新后的数据，不应该存在一个时刻，让用户读到更新过程中的数据。**因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
3. **隔离性**：**是指一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对正在进行的其他事务是隔离的，并发执行的各个事务之间不能互相干扰**，这个有点儿像我们打网游中的副本，我们在副本中打的怪和掉的装备，与其他副本没有任何关联也不会互相影响。
4. **持久性**：一个事务被提交之后。它对数据库中数据的改变是持久的，后续的其他操作和故障都不会对事务的结果产生任何影响

### mysql事务隔离级别对应的问题
1. 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
2. 不可重复读(Non-repeatable read)：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 **不可重复读通常针对数据更新（UPDATE）操作。**   
3. 幻读(Phantom Read)：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。**幻读是针对数据插入（INSERT）操作来说的**

### 事务隔离级别，对应的问题
> 类似问题：事务的隔离级别
> 类似问题：mysql 隔离级别
> 类似问题：mysql 的事务隔离级别有几种啊
!> 越往下效率越低

理解：SQL 标准定义了四个隔离级别：
1. READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
2. READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
3. REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
4. SERIALIZABLE(可串行化)： 最高的隔离级别，**对于同一行记录，“写”会加“写锁”，“读”会加“读锁”**。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

**mysql中默认使用可重读，oracle中默认使用读已提交**

### mysql事务的隔离级别以及分别如何实现？

!> 为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。
实现：MVVC机制以及undo_log

|   隔离级别  |   内容  |    解决的问题以及出现的问题   |  实现原理  |
| :--: | :--: | :--: | :--: |
|   READ-UNCOMMITTED(读取未提交)  |    最低的隔离级别，允许读取尚未提交的数据变更，  |     可能会导致脏读、幻读或不可重复读。   |  **读无锁。改启用行级共享锁** |
|    READ-COMMITTED(RC读取已提交) |   允许读取并发事务已经提交的数据，   |     可以阻止脏读，但是幻读或不可重复读仍有可能发生。   |   读取:行级共享锁；改：行级排它锁
|    REPEATABLE-READ(可重复读)  |   对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改   |   可以阻止脏读和不可重复读，但幻读仍有可能发生。   |  读取共享锁直到事务结束释放， 写排它锁直到事务结束释放    |
|    SERIALIZABLE(可串行化)  |  最高的隔离级别，**对于同一行记录，“写”会加“写锁”，“读”会加“读锁”**。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，    |   该级别可以防止脏读、不可重复读以及幻读。  |   读取*表级*共享锁直到事务结束释放。写*表级*排它锁直到事务结束释放   |

如何实现参考极客时间课程mysql实战45讲与https://blog.csdn.net/sanyuesan0000/article/details/90235335

### 事务的隔离有哪些,说一下每个隔离的区别,mysql默认使用哪个隔离,日常应用中应该使用已提交读还是可重复读

> 其他同上
!> 日常应用中推荐将隔离级别设计为已提交读

原因：
1. https://blog.csdn.net/weixin_42144277/article/details/106916092
2. https://www.cnblogs.com/fanguangdexiaoyuer/p/11323248.html#_label1

生产中使用RC隔离级别主要原因如下：

使用RR隔离级别，
1. 如果存在间隙锁，就容易产生死锁
2. 如果条件列未命中索引会引起锁表，其他事务只能读，不能写，影响性能。
3. 还有在RC隔离级别下，半一致性读（semi-consistent）的特性增加了update操作的并发性。
4. 
    4.1 mysql默认RR隔离级别是有历史原因的，mysql主从复制是基于binlog，在5.0以前binlog的格式（binlog_format）只支持statement格式（记录的是修改sql语句），这种格式在RC隔离级别下有BUG，因此mysql将RR隔离级别作为默认的隔离级别。
    4.2 这个BUG大致是这样：一张表test有字段x并且是主键，x列有一行数据：1；sessionA设置隔离级别为RC，然后开启事务。sessionB设置隔离级别为RC，也开启事务。sessionA执行 delete from test where x >= 3;不提交。sessionB执行 insert into test select 2；sessionB执行commit；提交成功。然后sessionA执行commit；提交成功。此时在主（master）上执行 select * from test;可以查到x列有值为2。但是此时在从（slave）执行select * from test;查到是空的。这样就产生主从不一致的问题！原因其实就是，在master上执行的顺序为先删后插，而此时binlog为statement格式，他记录的顺序是先插后删，从（slave）同步的是binlog，因此主从执行的顺序不一致，就会出现主从不一致。
    4.3 解决这个问题的方案有两种，1.就是设置隔离级别为RR，在该隔离级别下引入间隙锁，当sessionA执行delete时，会锁住间隙，sessionB执行insert时就会阻塞。2.将binlog的格式binlog_format改为row（记录的是每行实际数据的变更）。此格式是基于行的复制，自然就不会出现sql执行顺序不一样的问题！奈何row格式是在mysql5.1版本开始才引入的。因此由于历史原因，mysql将默认的隔离级别设为RR可重复读，保证主从复制不出问题。

### 提交读和可重复读的实现原理
> 以下答案来自于极客时间的mysql实战45讲
在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复 读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行 化”隔离级别下直接用加锁的方式来避免并行访问。

[参考](https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247485055&idx=1&sn=9ee2329c8793dbb86d38aa8592ba230c&chksm=e80db009df7a391f3f70776a9eabd246cc9093d6d04840812bab2efd023961290091230ee25a&scene=21#wechat_redirect)

### 事务的实现
实现：MVVC机制以及undo_log

简单讲，如果没有MVCC，当想要读取的数据被其他事务用排它锁锁住时，只能互斥等待；而这时MVCC可以通过提供历史版本从而实现读取被锁的数据的历史版本，从而避免了互斥等待。

InnoDB采用的MVCC实现方式是：在需要时，通过undo日志构造出历史版本

两个实现⽅式：
1. LBCC(lock based concurrent control)：基于锁的并发控制 
2. MVCC(multi-verson concurrent control)：多版本的并发控制。
具体参考自己总结的笔记

如何实现参考极客时间课程mysql实战45讲与https://blog.csdn.net/sanyuesan0000/article/details/90235335

!> 类似问题： 如何实现事务 我就回答了MVCC + 一顿猛吹

### 事务的几个特性 2次 事务的特性以及对应的问题，如何保证的
!> 事务的特性以及对应的问题同上

**那ACID靠什么保证的呢？** 参考: https://blog.csdn.net/weixin_39524574/article/details/111693947
1. A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
2. C一致性一般由代码层面来保证
3. I隔离性由MVCC来保证
4. D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复
### mysql 的事务锁了解吗

### 那每一个事务隔离级别分别解决了什么问题呢
> 类似问题：那可重复读能解决什么
读未提交：出现脏读，不可重读，幻读问题
读已提交：解决脏读问题，出现不可重读，幻读问题
可重读：出现幻读问题，解决脏读，不可重读
序列化：解决脏读，不可重读，幻读问题

### 讲讲可重复读隔离级别
如何实现参考极客时间课程mysql实战45讲与https://blog.csdn.net/sanyuesan0000/article/details/90235335

[事务隔离实现参考](https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247485055&idx=1&sn=9ee2329c8793dbb86d38aa8592ba230c&chksm=e80db009df7a391f3f70776a9eabd246cc9093d6d04840812bab2efd023961290091230ee25a&scene=21#wechat_redirect)

### 事务相关：例如事务的隔离是如何实现的？事务是如何保证原子性？不同的事务看到的数据怎么就不一样了？难道每个事务都拷贝一份视图？MVCC 的实现原理（重要）等等。

[事务隔离实现参考](https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247485055&idx=1&sn=9ee2329c8793dbb86d38aa8592ba230c&chksm=e80db009df7a391f3f70776a9eabd246cc9093d6d04840812bab2efd023961290091230ee25a&scene=21#wechat_redirect)

------------
## 索引


[参考](https://juejin.cn/post/6942777635579625503)

[参考](https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247484041&idx=1&sn=76d3bf1772f9e3c796ad3d8a089220fa&chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&token=2025456560&lang=zh_CN#rd)

### 索引的结构以及概念
1. 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。
2. 索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B数及其变种B+数。
3. 更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。

### mysql索引的数据结构以及分类(B+树以及和B-树，红黑树，二叉树的优缺点，聚簇索引，非聚簇索引，hash索引的优缺点以及实现)

聚簇索引，是每一个叶子节点最终都保留了一整行的记录信息，不需要进行回表，直接可以查找到
但是非聚簇索引是每一个叶子节点都保留对应的主键值，通过主键进行回表来获取对应的记录信息，需要查两次

>类似问题： 数据库索引结构是什么样的（我回答B+树，然后问对磁盘有什么优势夺命追问，我说降低IO次数，问为什么）
>类似问题： 数据库使用b+树的好处
>类似问题： b+树的特性，为啥要用到这
>类似问题： B+ Tree
>类似问题： 谈谈索引的数据结构？说了 B+树
>类似问题： B+树和 B-树的区别以及优点？
>类似问题： 为什么不用搜索树？
>类似问题： B+树的特点
>类似问题： mysql 索引 2次
>类似问题：mysql索引结构。

索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。
1. B树索引：mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）
2. B+tree性质：n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。
所有的叶子结点中包含了全部关键字的信息，即指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
所有的非终端结点可以看成是索引部分，结点中仅含其子数中的最大（或最小）关键字。
B+ 树中，数据对象的插入和删除仅在叶节点上进行。
B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。
3. 哈希索引：简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。


别人的：
这个问题会涉及到mysql的存储数据结构，B+tree
多叉搜索树，有序，类似二叉搜索树(特性:中序遍历是有序的);curd的时间复杂度都是logN;
再谈谈mysql的索引结构，innodb引擎中分主键(聚簇索引)索引树和二级索引树;
Innodb的主键索引树的叶子节点上存储行数据，非叶子结点只存储主键id，简单讲就是聚簇索引相当于物理内存地址(一级指针)，查询快;
而二级索引树的每个节点只会存储索引字段值和主键id;
2种索引查询对比:
主键索引树:主键id=>叶子结点row数据
二级索引树: 二级索引树上找到对应的id=>主键索引树上的id=>主键索引树上的叶子结点行记录

上面“二级索引树=>主键索引树”的过程叫做“回表”，可以通过“索引覆盖”，“索引下推”优化

个人总结，可能不准确的地方
### 数据库中数据很多的时候如何处理？面试官提示了索引

### 索引越多越好么？
> 不一定，通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。
索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:
1. 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%
2. 基于非唯一性索引的检索

### B+树有什么好处
> 参考：https://zhuanlan.zhihu.com/p/140876416
1. 由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 
2. B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历甚至有可能需要回旋查找，这会需要更多的内存置换次数，因此也就需要花费更多的时间

### 那么对于mysql来说为什么采用b+树而不采用b树
自己说有效减少磁盘IO次数，可以提高

追问：B树同样也是一样的树高也可以做的很低呀，

B树占用内存比较大，B+树只是在叶子节点存放我们需要的数据

追问：占用很大内存怎么理解

B+树搜索经过路径中节点的时候，比如主键，只会保存主键的值，并不会保存其他列的记录信息，只是在最后到叶子节点的时候才会保存一整行的记录，所以B+树会比B树占用内存小，

追问：既然mysql索引是b+树，有一种特殊的索引是联合索引你知道么，


### 二叉树，b 树，b+树的区别
> 类似问题：对于数据结构里面，二叉树，二叉搜索树，B树，B+树，这四种树你能谈一下你的理解么
**B树与B+树的区别**
B树每个节点都存储数据，所有节点组成这棵树。B+树只有叶子节点存储数据（B+数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。

B树中叶节点包含的关键字和其他节点包含的关键字是不重复的，B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。

B树中每个节点（非根节点）关键字个数的范围为[m/2(向上取整)-1,m-1](根节点为[1,m-1])，并且具有n个关键字的节点包含（n+1）棵子树。B+树中每个节点（非根节点）关键字个数的范围为[m/2(向上取整),m](根节点为[1,m])，具有n个关键字的节点包含（n）棵子树。

B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。

**B树的优点**
1. B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。

**B+树的优点**
所有的叶子结点使用链表相连，便于区间查找和遍历。B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。
b+树的中间节点不保存数据，能容纳更多节点元素。
B树和B+树的共同优点
考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，m的大小取决于磁盘页的大小。

### InnoDB二级索引流程
### 主键和索引的区别
### mysql索引类型有哪些

### 如何提高索引的速度
### innodb的索引有哪些
### 联合索引的使用原则

### 联合索引在b树，b+树的结构是怎么样的，查找过程你了解过么
查找过程可以理解为：最左匹配原则
[参考](https://zhuanlan.zhihu.com/p/109623980)
### 如何创建索引
### 数据库的索引
### mysql索引
### mysql 索引慢分析（线上开启slowlog，提取慢查询，然后仔细分析explain 中 tye字段以及extra字段，发生的具体场景及mysql是怎么做的，被表扬回答的不错）

### 了解Mysql中的索引：涉3树是这样的一颗多路查找树，其中每一个节点都具有两个孩子及到什么是B树，与二叉搜索树和平衡二叉树区别，以及B+树区别
二叉排序树(Binary Sort Tree)，又称为二叉查找树，它或者是一颗空树，或者是具有下列性质的二叉树：
1. 若它的左子树不为空，则左子树上所有节点的值均小于它的根节点的值
2. 若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值
3. 它的左右子树也分别为二叉排序树

平衡二叉树(self-Balancing Binary Search Tree，也叫做AVL树)，是一种二叉排序树，其中每一个节点的左右子树的高度差至多等于1
前提首先是一颗二叉排序树，而后需要保持平衡特性所以就叫做平衡二叉树。

2-(我们称为2节点)或三个孩子(我们称为3节点)

一个2节点包含一个元素和两个孩子(或没有孩子)，且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素，不过与二叉排序树不同的是，这个2节点要么没有孩子，要么就有两个，不能只有一个孩子。

一个3节点包含一小一大两个元素和三个孩子（或没有孩子），一个3节点要么没有孩子，要么具有3个孩子，如果某个3节点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间元素包含介于两元素之间的元素。

2-3-4树包含了4节点的使用，一个4节点包含小中大三个元素和四个孩子(或没有孩子)，一个4节点要么没有孩子，要么具有4个孩子，如果某个4节点有孩子的话，左子树包含小于最小元素的元素，第二子树包含大于最小元素、小于第二元素的元素，第三子树包含大于第二元素，小于最大元素的元素，右子树包含大于最大元素的元素

B树是一种平衡的多路查找树，2-3树与2-3-4树都是B树的特例，节点最大的孩子数目称为B树的阶。因此，2-3树是3阶B树，2-3-4树是4阶B树
![IMG_0379](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/IMG_0379.jpg)

B+树参照《大话数据结构》P352

### 数据库的索引

### 数据库覆盖索引

假设我们有张表，结构如下：

create table user( id int(11) not null, age int(11) not null, primary key(id), key(age) );

覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。

而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。

以上面的user表来举例，我们再增加一个name字段，然后做一些查询试试。

explain select * from user where age=1; //查询的name无法从索引数据获取 explain select id,age from user where age=1; //可以直接从索引获取

### 数据库聚集索引和辅助索引

### MySQL 的索引
后面的问题：为什么用 b+树
b 和 b+区别

### 何时使用索引

### 索引是如何实现的？多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）

------------
## 锁
### mysql的锁类型
[参考](https://blog.csdn.net/qq_34337272/article/details/80611486) + 自己总结的mysql MVCC中的涉及到锁的笔记

### 行锁什么时候变表锁
1. 事务的隔离级别为：可重复读时，如果有索引（包括主键索引），以索引列为条件更新数据，会存在间隙锁，行锁，页锁，而锁住一些行。如果没有索引，更新数据时会锁住整张表。
2. 事务隔离级别为：串行化时，读写数据都会锁住整张表。（一次只能一个连接玩表）
### select语句什么时候行锁什么时候变表锁
InnoDB 的锁，与索引类型，事务的隔离级别相关。InnoDB 到底是行锁还是表锁取决于你的 SQL 语句。如果查询没有命中索引，也将退化为表锁。InnoDB 的行锁是实现在索引上的，而不是锁在物理行记录上。所以如果访问没有命中索引，也无法使用行锁，将要退化为表锁。

参考：[InnoDB 的 select 行锁还是表锁](https://www.xttblog.com/?p=3053)
### mysql的锁

### 用什么语句实现数据库锁

### innodb的一些特性，和Myisam的，行锁表锁

### 各种锁相关，例如表锁，行锁，间隙锁，共享锁，排他锁。这些锁的出现主要是用来解决哪些问题？（重要）

间隙锁：间隙锁是可重复读级别下才会有的锁，结合MVCC和间隙锁可以解决幻读的问题。我们还是以user举例，假设现在user表有几条记录

e data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal">
当我们执行：

begin; select * from user where age=20 for update; begin; insert into user(age) values(10); #成功 insert into user(age) values(11); #失败 insert into user(age) values(20); #失败 insert into user(age) values(21); #失败 insert into user(age) values(30); #失败

只有10可以插入成功，那么因为表的间隙mysql自动帮我们生成了区间(左开右闭)

(negative infinity，10],(10,20],(20,30],(30,positive infinity)

由于20存在记录，所以(10,20]，(20,30]区间都被锁定了无法插入、删除。

如果查询21呢？就会根据21定位到(20,30)的区间(都是开区间)。

需要注意的是唯一索引是不会有间隙索引的。

------------
## 存储引擎

### innodb的一些特性，和Myisam的，行锁表锁

### mysql中innodb引擎

### 知道哪些存储引擎

### 存储引擎在MySQL这个系统架构的哪个位置

### innodb与myisam的区别

### mysql的存储引擎

------------
## 设计
### 数据表设计遵循的原则

### 数据库三大范式
1. 第一范式：每个列都不可以再拆分。
2. 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。
3. 第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。
在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。
### 一范式为什么要列不可分割

### 设计学生成绩系统，如何建表，如何建索引


### 数据库表是如何设计的

------------
## 其他问题
### 数据库完整性的实现
### 主键
### 介绍mysql
### 数据库中有两个关联列，请问在搜索时，这两个关联列会怎样？
### Mysql怎么去查询的，什么时候走索引，什么时候不走
### Mysql了解什么，有没有搭过mysql、redis
### 数据库的部署怎么做
### 读写分离具体怎么做
### 数据库优化+缓存（缓存的不一致，binlog解析器），读写分离，分库分表
### mysql怎么存储时间
### mysql把邮戳转化为日常格式时间的函数
### sql慢查询
### 如果一个表查询，插入等很慢，你怎么做？
### mysql 分布式id（项目用到的）
### sql语句：查询所有课程分数都大于或等于80分的学生姓名
### 写个sql语句，两张表，学生表，学生课程表，求平均分大于85的学生的姓名
### sql语句：表【学生|科目|成绩】查询每个学生成绩最好的科目和成绩 ( 没完全写出来
### mysql 和 mongodb 的区别，什么时候用 mysql，什么时候用 mongo（因为简历上 有写 mongodb）
### 给定一张表 user(id,name,age)
有这样一个查询
select id,name,age where name=....
如何建立索引，并且使用到覆盖索引
### 一个教务系统，包括学生信息，课程信息，考试安排，成绩查询，绩点分析，你来设 计数据库表应该怎么设计？
用你刚刚设计的表来给我查询出全校所有高数在 85 分一以上的人的名字
### char 和 varchar
SQL：userId(主播 Id) de..Id(设备 Id)，怎么实现对主播与主播之间的重合数（共同关注数）
### SQL，一个表 User，字段 userid，username，city 查询用户数量最多的三个城市。
### MySQL 的自增主键和随机生成主键的区别，为什么自增主键效率高。
### 如何查看数据库表结构？
### 如何提高 SQL 查询效率，在语句方面上的优化？
### 一条 sql 语句是如何执行的？进行更新时又是怎么处理的？
### 日志相关：redolog，binlog，undolog，这些日志的实现原理，为了解决怎么问题？日志也是非常重要的吧，面试也问的挺多。
redolog 用于日志重放，宕机时，可以保证数据未提交的数据，正常提交
undolog  用于 mvccc ，事务回滚
binlog 是 server 层的，其它两个是引擎层的.binlog同步和恢复数据，


日志只要看这3篇文章就可以了：
1. https://mp.weixin.qq.com/s/zjtYYPbBNuhgAHtf1zxFrQ
2. https://mp.weixin.qq.com/s/Eb95fGhyvLThOF9uhQYVDg
3. https://mp.weixin.qq.com/s/rmQYMGfgyfLlo69l6SBbLQ

[redolog,binlog,undolog](https://juejin.cn/post/6941988998038421518?utm_source=gold_browser_extension)

b站的表同步好像就是订阅的binlog
undo原子性，redo持久性
![Vs9wv3c7HbAqajP](https://i.loli.net/2021/03/24/Vs9wv3c7HbAqajP.png)


mvcc只有RC 和  RR级别有
读提交和可重复读是 mvcc
RR级别通过  Next-Key锁防止幻读

大家一般用哪个级别？我看互联网都是RC
并发量大的用RC

![OrJxSocG74IfqzW](https://i.loli.net/2021/03/24/OrJxSocG74IfqzW.png)

RR通过Next-key锁解决幻读
![bosXwVDyOLq7MUK](https://i.loli.net/2021/03/24/bosXwVDyOLq7MUK.png)

RR有next-key lock解决了幻读 = RR没幻读 
next-key lock 是 行锁 + 间隙锁
![R42PgZiXnCBEhcO](https://i.loli.net/2021/03/24/R42PgZiXnCBEhcO.png)
![odDUzTrCpuBPIgv](https://i.loli.net/2021/03/24/odDUzTrCpuBPIgv.png)
![8fFxAwiCnBrlXW5](https://i.loli.net/2021/03/24/8fFxAwiCnBrlXW5.png)
RR下会产生幻读 但是 InnoDB和XtraDB通过MVCC解决幻读了
MVCC是解决不可重复读


![GckayhpHrtlz2sm](https://i.loli.net/2021/03/24/GckayhpHrtlz2sm.png)
### 数据库的主从备份、如何保证数据不丢失、如何保证高可用等等。

## 如何保证多个服务器的数据一致性
我能想到的思路是从分布式出发
1.先从 cap 理论将其
2.然后从常用的 mysql 的主从同步是最终一致性将其
3.可以的话从服务发现分析（go的etcd,consult，还有常用的zk）
4.从业务场景出发，是保证强一致性（秒杀业务），还是最终一致性（实时性要求不高的业务）
## 建立一张数据库表需要考虑哪些因素，索引的底层实现，是否了解过b+树之外的索引结构。




